了解しました。ActivityPubソフトウェアに組み込むための、APIのみを対象としたメッセージング機能（End-to-End
Encryption付き）の仕様書を、Deno + Hono 環境で実装できるようにまとめます。
しばらくお待ちください。

# ActivityPub対応ソフトウェアへのE2EEメッセージング統合技術仕様

## 概要 (Overview)

本書は、既存のActivityPub互換ソフトウェアにエンドツーエンド暗号化（E2EE）のメッセージング機能を追加統合するための技術仕様を示します。対象はサーバ側のAPIレイヤーのみであり、フロントエンドのUI実装は含みません。実装にはDenoランタイムとHonoフレームワークを使用し、オープンソースのE2EE実装（[swicg/activitypub-e2ee](https://github.com/swicg/activitypub-e2ee)プロジェクト）で提案されている方式に基づいています。この方式では、ActivityPub標準のプロトコル上で暗号化ペイロードをカプセル化し、既存の連合型ソーシャルネットワークにシームレスに組み込むことを目指します。具体的には、ActivityPubのメッセージ配送機能を暗号化メッセージの「エンベロープ」とし、Messaging
Layer Security (MLS)
による暗号化層を重ねる構造を採用します。その結果、サーバはメッセージ内容を解読せずに既存のActivityPubアクター間で暗号化メッセージを配送でき、クライアント間でエンドツーエンドのセキュア通信が実現されます。

## APIエンドポイント定義 (API Endpoints)

E2EEメッセージング機能のために、新たに以下のAPIエンドポイント（REST形式）を提供します。各エンドポイントは認証済みユーザーのみが利用可能であり、JSON形式のデータを送受信します。**※URI中の`{user}`はアクターIDやユーザー名等、対象ユーザーを示す識別子です。**

- **公開鍵取得: `GET /api/users/{user}/keyPackages`**
  指定したユーザーの公開鍵パッケージ一覧を取得します。公開鍵パッケージ（KeyPackage）は、暗号化通信に使用される公開鍵および関連メタデータの集合です。レスポンスはアクターの`keyPackages`コレクション（ActivityPubのCollectionオブジェクト）として、現在有効な公開鍵パッケージのリストを返します。他のユーザー（他サーバー上も含む）の公開鍵取得にも利用され、クライアントはこれを用いて受信相手の公開鍵を入手します。
  なお、ここでの `{user}` は **`username@example.com`** 形式で指定します。

- **公開鍵登録: `POST /api/users/{user}/keyPackages`**
  新たな公開鍵パッケージを自分のキーコレクションに追加します。クライアント側で鍵対（公開鍵・秘密鍵）を生成し、その公開鍵情報（例えばMLSのKeyPackageバイナリをbase64エンコードしたもの等）を本エンドポイントに送信します。サーバは受信した公開鍵パッケージオブジェクトをActivityPubオブジェクトとして作成し（`Create`アクティビティ）、アクターの`keyPackages`コレクションに追加します。公開鍵は基本的に全体公開
  (`to`: `as:Public`)
  で配布され、他サーバーからも取得可能になります。レスポンスとして新規キーのIDや登録結果を返します。

- **公開鍵削除: `DELETE /api/users/{user}/keyPackages/{keyId}`**
  古い公開鍵パッケージを無効化または削除します。`{keyId}`で指定されたキーをアクターの`keyPackages`コレクションからRemoveし、必要に応じてDeleteします。この操作により、当該公開鍵では新規メッセージを受信しないようになります（古い鍵で暗号化された過去メッセージは引き続き復号可能）。キーの削除は鍵のローテーションやデバイス紛失時の無効化に利用します。

- **メッセージ送信: `POST /api/users/{user}/messages`**
  認証ユーザー（送信者）からの暗号化メッセージを送信します。リクエストボディには以下の情報を含みます。
  ここでの `{user}` も **`username@example.com`** 形式で指定してください。 (a)
  受信者一覧（`to`フィールドに配列でユーザーのActor URIを指定）、(b)
  暗号化されたメッセージコンテンツ（クライアント側で暗号化済みのデータ。MLSプロトコルに則りbase64エンコードしたバイナリ文字列）、(c)
  必要に応じてメッセージの種別やメタ情報。サーバは受信すると、ActivityPubの`Create`アクティビティを生成し、`object`プロパティに暗号化メッセージオブジェクト（タイプ`PrivateMessage`）を内包したうえで送信処理を行います。メッセージは各受信者のInbox（受信ボックス）へ配送されます。本エンドポイントのレスポンスとして、メッセージオブジェクトのIDや送信ステータスを返します。

- **メッセージ受信取得: `GET /api/users/{user}/messages`**
  認証ユーザー（受信者）の新着暗号化メッセージ一覧を取得します。サーバ側で管理しているInboxコレクションから、当該ユーザー宛に届いた暗号化メッセージ（`Create`アクティビティ内に`PrivateMessage`オブジェクトを含むもの）のみをフィルタして返します。レスポンスはメッセージごとに、送信者、メッセージID、暗号化ペイロード、タイムスタンプ等を含むJSONリストとなります。クライアントはこれらの暗号化ペイロードを取得し、自身の秘密鍵で復号してメッセージ本文を得る流れです。なお、ActivityPub仕様上はInbox全体を`GET`で取得可能であり、必要に応じてクライアントは定期ポーリングでInboxから新規メッセージを確認します。`{user}`
  の指定は送信時と同様に **`username@example.com`** 形式です。

_補足:_ 上記のエンドポイントは、ActivityPubクライアント-to-サーバ(C2S)
APIおよびサーバ間(S2S)連合プロトコルを内部で利用しています。例えばメッセージ送信は内部的にはユーザーのOutboxに対する`Create`投稿であり、受信取得はInboxコレクションの内容を返すものです。これらRESTエンドポイントはクライアント実装を容易にするラッパーとして設計されています。

## 暗号化処理フロー (Encryption Flow)

E2EEメッセージの送受信は、以下の手順で行われます。

1. **鍵取得とセッション準備:**
   メッセージを送るクライアントは、まず受信者全員の公開鍵（KeyPackage）を取得します。自サーバ内のユーザー宛であれば`GET /api/users/{user}/keyPackages`で取得し、他サーバのユーザー宛の場合はActivityPubのアクターURLを解決してその`keyPackages`をフェッチします。取得した各受信者の公開鍵情報に基づき、クライアント側で暗号化セッションの初期化を行います。初回のメッセージ送信時には、MLSプロトコルに従って新しいグループ（1対1の場合も内部的には2者グループ）を作成し、必要な共有鍵マテリアルを生成します。MLSのグループ作成時には、各参加者のKeyPackageを使用して「Welcomeメッセージ」やグループ情報を暗号化・署名し、後続のメッセージに備えます。このWelcomeメッセージは最初の暗号化メッセージとともに配送され、受信者は自分の秘密鍵で復号することでグループ共有鍵を獲得します。

2. **クライアント側でのメッセージ暗号化:**
   送信クライアントはユーザーが入力したメッセージ本文を平文で保持します。次に、上記で用意したセッション鍵（またはプリミティブとしてのMLSの各メッセージ鍵）を用いてメッセージ本文を暗号化します。暗号化には、選択したプロトコル（例:
   ダブルラチェット方式やMLSのAES-GCM等）が提供する手段を用い、結果としてバイナリデータの暗号文と認証タグが得られます。クライアントはこれをBase64エンコードし、ActivityPubメッセージオブジェクトの`content`フィールドに埋め込みます。また`mediaType`は`"message/mls"`とし、`encoding`プロパティで`"base64"`でエンコードしていることを示します。これらフィールドにより、サーバや他のクライアントに対し「このコンテンツはMLS方式で暗号化されたバイナリである」ことを示します。必要に応じ`summary`フィールドに「暗号化されたメッセージである」旨の短い説明を入れることもできます（非対応クライアントへの表示用）。

3. **サーバへの送信 (アウトボックス処理):**
   クライアントは暗号化済みメッセージオブジェクトをサーバAPIに送信します
   (`POST /api/users/{user}/messages`)。サーバはリクエストを受け取ると、認証情報から送信者のアクターを特定し、ActivityPubの`Create`アクティビティを構築します。この`Create`の`object`に、クライアントから提供された暗号化メッセージ（`type`:
   `"PrivateMessage"`）をそのまま組み込みます。`to`プロパティには受信者のアクターIDのリストが入り、**フォロー一覧**や**公開宛
   (Public)**
   などコレクションは指定されません（E2EEメッセージでは受信者を明示的に列挙する必要があります）。サーバはこのアクティビティとオブジェクトに一意の`id`を付与し、自身のデータベースに保存した上で、各受信者の所属するサーバへ配信（HTTP配送）します。配信時にはActivityPubサーバ間プロトコルに従い、HTTP署名や必要な認証ヘッダを付与して送信者サーバから受信者サーバのインボックス
   (`inbox` URL) にHTTP POSTします。

4. **他サーバへの配送と受信処理:**
   宛先がリモートのActivityPubサーバである場合、送信サーバからの署名付きリクエストを受信した各サーバは、その要求を検証した後、暗号化メッセージ付きの`Create`アクティビティを自サーバ内の受信者ユーザーのインボックスに保存します。暗号化されたコンテンツは`mediaType`で示されているため、受信サーバは内容を解釈しません。メッセージの内容は不明ですが、ActivityPubの仕様に則りオブジェクト自体は保存・転送されます（不正なデータでない限り）。なお、対応していないサーバでは未知の`PrivateMessage`型を持つアクティビティとなりますが、AS2拡張の扱いとして無視されるか、あるいは`Object`として処理される可能性があります。

5. **クライアント側での受信と復号:**
   受信者のクライアントは、自身のサーバに対して新着メッセージをポーリングまたは通知（※ActivityPub標準ではプッシュがないためポーリングが基本）で確認します。`GET /api/users/{user}/messages`エンドポイントから取得したメッセージ一覧には、暗号化ペイロード（base64文字列）が含まれています。クライアントアプリは自分の秘密鍵を用いてこれを復号します。MLSプロトコルを用いている場合、受信メッセージに含まれるシーケンス番号や鍵エポック情報に基づき、適切なステップで鍵導出・復号を行います。復号に成功すれば、元の平文メッセージが得られユーザーに表示されます。以降、同じ相手とのやり取りでは、各メッセージ送受信のたびにプロトコル内部で前方秘匿性を保つための鍵更新（ラチェット）が行われ、クライアント側で暗号/復号処理が進みます。

以上が基本的な暗号化メッセージ送受の流れです。重要な点は、**暗号化・復号の処理はクライアント側で全て行われ、サーバ側では暗号文を配送するだけ**であることです。サーバ管理者でさえメッセージ内容を知ることはできません。複数人グループチャットの場合も、概念的には上記と同様ですが、MLSプロトコルによりグループ全体で共有する鍵が管理され、メンバー追加・離脱時には新たな鍵共有（既存メンバーによる既存鍵の棄却と新鍵発行・配布）が行われます。この処理もActivityPubメッセージ（例:
`Welcome`や`GroupInfo`型オブジェクト）として暗号化されて配送され、クライアントが適宜処理します。

## 鍵管理 (Key Management)

E2EEシステムでは鍵（公開鍵・秘密鍵ペア）の安全な管理が不可欠です。本仕様での鍵管理方針は以下の通りです。

- **鍵ペアの生成:**
  E2EE機能を有効にするユーザーは、クライアントアプリ上で暗号鍵ペアを生成します。一般的にはCurve25519やX25519などの楕円曲線暗号、もしくはMLSライブラリ内で定義されたキー構造を使用します。鍵生成は必要に応じてデバイスごとに行うことができます（例えばユーザーが複数デバイスで同一アカウントを使用する場合、それぞれに鍵ペアを発行可能）。生成された秘密鍵はクライアント側で厳重に保持し、公開鍵情報（およびプロトコルが要求する付随データ）はサーバの公開鍵コレクションに登録します（前述の`POST /api/users/{user}/keyPackages`経由）。

- **公開鍵パッケージ (KeyPackage):**
  公開鍵に関連する情報はActivityPub上では`KeyPackage`オブジェクトとして表現されます。各`KeyPackage`には、暗号プロトコルで利用される公開鍵本体（例:
  クライアントのエポック公開鍵、またはプリキー）、およびそのメタデータ（プロトコルバージョン、暗号スイート、発行者署名など）が含まれています。`KeyPackage`オブジェクトはバイナリ形式のデータをbase64エンコードして`content`に保持し、`mediaType`に`message/mls`を指定することで、内部がMLSプロトコルの定義するシリアライズ形式であることを示します。公開鍵パッケージはサーバ上では**公開情報**として扱われ、ユーザーのActorプロファイルに紐づけられた`keyPackages`コレクションで公開・配布されます。例えばアクターオブジェクトのJSONは以下のようになります。

  ```json
  {
    "@context": [
      "https://www.w3.org/ns/activitystreams",
      "https://purl.archive.org/socialweb/mls"
    ],
    "id": "https://example.com/users/alice",
    "type": "Person",
    "inbox": "https://example.com/users/alice/inbox",
    "outbox": "https://example.com/users/alice/outbox",
    "keyPackages": {
      "type": "Collection",
      "id": "https://example.com/users/alice/keyPackages",
      "totalItems": 1,
      "items": [
        "https://example.com/users/alice/keyPackage/ABCD1234"
      ]
    }
  }
  ```

  _上記はAliceというユーザーのアクター情報の一部であり、`keyPackages`プロパティにそのユーザーの公開鍵パッケージのコレクションが示されています。現在1件のKeyPackageオブジェクトへのリンクを含みます。_

- **鍵のローテーション:**
  エンドツーエンド暗号のセキュリティ維持のため、定期的または必要に応じて暗号鍵をローテーション（更新）します。ユーザーが新しい鍵ペアを生成しサーバに登録すると、サーバは新KeyPackageを作成し、アクターの`keyPackages`コレクションに`Add`アクティビティで追加します。古い鍵は引き続き`keyPackages`コレクション内に残りますが、クライアントは原則として最新のKeyPackageを用いて新規メッセージのセッション確立を行います。必要に応じ、一定期間経過した鍵や漏洩が疑われる鍵は`Remove`と`Delete`によってコレクションから除外・削除します。この操作は`DELETE /api/users/{user}/keyPackages/{keyId}`エンドポイントでトリガでき、内部的にはActivityPubの`Remove`/`Delete`活動として各サーバに共有されます。鍵を削除すると、その鍵に対応する暗号セッションは新規には確立できなくなります（過去にその鍵で暗号化されたメッセージは受信者側に秘密鍵が残っている限り復号可能）。

- **秘密鍵の保管:**
  秘密鍵はクライアント側のみで保持し、決してサーバに平文で送信しません。クライアントアプリはデバイスのセキュアストレージ機能（例:
  モバイルOSのKeychainやSecure
  Enclave、Webの場合はIndexedDBに暗号化して保存する等）を活用し、秘密鍵を保管します。万一デバイスが乗っ取られ秘密鍵が漏洩すると、その鍵で暗号化されたメッセージの機密性は損なわれるため、秘密鍵保護は極めて重要です。鍵は可能ならユーザーのパスフレーズ等で追加暗号化して保存し、復号時に都度パスフレーズを要求することも検討します。サーバ側では秘密鍵は一切保存しません。どうしてもサーバ上にバックアップする場合は、ユーザー提供のパスワードで暗号化してから保存するようにします。

- **鍵情報の検証:**
  公開鍵はユーザーの所属サーバから配布されますが、悪意あるサーバ管理者がユーザーの鍵を差し替える（偽の鍵を配布する）攻撃の可能性があります。このリスクに対処するため、本仕様では**キー指紋の検証**を推奨します。具体的には、ユーザー同士がオフラインで会うか別の安全な経路で、お互いの公開鍵フィンガープリント（ハッシュ）を照合する仕組みを用意します。クライアントアプリは通信相手のKeyPackageのフィンガープリントを表示し、ユーザーが事前に交換・信頼している値と一致するか確認できるようにします。これにより、中間サーバによる鍵差し替え攻撃を検知することが可能になります。

## メッセージ形式 (Message Format)

クライアント間でやり取りされるメッセージデータは、ActivityPubのActivityStreamsオブジェクトとして定義されます。本仕様では暗号化メッセージを表す新たなタイプ`PrivateMessage`を使用します。これにより、標準のActivityStreamsに独自拡張を加えて暗号化ペイロードを扱います。メッセージ送信時には、`Create`アクティビティの`object`フィールドにこの`PrivateMessage`オブジェクトを含めて配送します。`PrivateMessage`オブジェクトおよび関連する暗号化データオブジェクトの形式は以下の通りです。

- **`PrivateMessage`オブジェクト:**
  暗号化されたメッセージ本体を表すオブジェクトです。ActivityStreamsでは`Object`を拡張する形で定義され、`@context`にMLS拡張のコンテキストURIを含めます。主なプロパティは次の通りです:

  - `type`: `"PrivateMessage"`（他に`"Object"`も併記される場合あり）
  - `attributedTo`: メッセージの送信者（アクターのURI）
  - `to`: メッセージの受信者リスト（アクターURIの配列）
  - `summary`: **(任意)** 暗号化メッセージである旨の説明文（例:
    `"このメッセージは暗号化されています"`）。E2EE非対応クライアントやUIで表示される可能性があります。
  - `mediaType`: `"message/mls"`
  - `encoding`:
    `"base64"`（contentがどのようにエンコードされているかを示す。base64を使用）
  - `content`:
    暗号化されたメッセージのペイロードデータ（base64文字列）。MLSプロトコルで定義される**PrivateMessage**形式のバイナリデータをエンコードしたものです。これには元のメッセージ本文の暗号文と必要なプロトコルヘッダ・認証情報が含まれます。

  **例:** 暗号化メッセージを内包したCreateアクティビティのJSON構造（簡略化）:

  ```json
  {
    "type": "Create",
    "actor": "https://example.com/users/alice",
    "to": ["https://otherserver.example.org/users/bob"],
    "object": {
      "type": ["Object", "PrivateMessage"],
      "attributedTo": "https://example.com/users/alice",
      "to": ["https://otherserver.example.org/users/bob"],
      "mediaType": "message/mls",
      "encoding": "base64",
      "content": "BASE64_ENCODED_CIPHERTEXT_BLOB"
    }
  }
  ```

  上記の`content`部分に、実際の暗号化ペイロードが入ります。`mediaType`が`message/mls`であることから、コンテンツはMLSメッセージ（例えばアプリケーションデータであるPrivateMessage型）のシリアライズであると示しています。

- **`KeyPackage`オブジェクト:**
  鍵共有のために使われるオブジェクトです。各ユーザー（アクター）は複数のKeyPackageを持つことができます。KeyPackageオブジェクトも`Object`の一種であり、`type`:
  `"KeyPackage"`として扱います。公開鍵本体やプロトコル情報を含むバイナリデータを`content`に格納し、`mediaType`:
  `"message/mls"`, `encoding`:
  `"base64"`を指定する点はPrivateMessageと似ています。違いは、このオブジェクト自体がメッセージではなく「鍵情報」であり、`to`:
  `as:Public`（公開）で共有される点です。KeyPackageオブジェクトはActivityPub上で公開されるため、`id`を持ち単独で参照可能です。アクターの`keyPackages`コレクションから各オブジェクトのURIが取得でき、そのURIにHTTP
  GETアクセスすることで詳細（contentフィールドに含まれるbase64鍵データなど）を取得できます。なおKeyPackageには各鍵に一意のIDを与えるために`id`プロパティが必要であり、例えば`https://example.com/users/alice/keyPackage/ABCD1234`のようなURLになります。

- **MLSプロトコルメッセージ:**
  上記のPrivateMessageやKeyPackageの`content`内部には、実際のMLSプロトコルのメッセージ構造がバイナリで格納されています。MLSでは様々なタイプのメッセージ（PublicMessage,
  PrivateMessage, Welcome, GroupInfo,
  KeyPackage）が定義されています。ActivityPub上ではそれぞれに対応するオブジェクトタイプ拡張が用意されており、本仕様では主にPrivateMessage（暗号化された通常メッセージ本文）とKeyPackage（鍵情報）を扱います。グループの初期共有に必要なWelcomeメッセージやGroupInfo（グループ状態）は、必要に応じてこれらも`Create`に乗せて配送されます。例えば、新しいグループ開始時には送信者が`Welcome`オブジェクトを作成し受信者へ送ります。Welcomeも内部はバイナリで、MLSのWelcomeフレームワークメッセージをbase64化した`content`を持つオブジェクトです。ただし、こうしたMLSレベルの詳細はクライアント実装内部の問題であり、サーバAPI上はそれが単に暗号化データとして転送・保管される点を押さえておきます。

## Honoフレームワークでの実装例とDeno特記事項 (Hono Controller Examples & Deno Notes)

本章では、Deno上でHonoフレームワークを利用して上記APIを実装する際のコントローラ構造例と、Deno環境特有の考慮点を示します。

### コントローラ実装例 (Hono Controller Structure)

Honoはエクスプレス風のインターフェースを持つ軽量Webフレームワークです。以下に、主要なエンドポイントの実装例をTypeScriptライクな擬似コードで示します（認証・エラーハンドリング等を簡略化しています）。

```typescript
import { Hono } from "hono";
const app = new Hono();

// 公開鍵一覧取得
app.get("/api/users/:user/keyPackages", async (c) => {
  const user = c.req.param("user");
  // ユーザーのKeyPackageコレクションをDBから取得
  const keyPackages = await db.getKeyPackages(user);
  return c.json(keyPackages); // { type: 'Collection', items: [ ... ] } を返す
});

// 公開鍵登録
app.post("/api/users/:user/keyPackages", async (c) => {
  const user = c.req.param("user");
  const newKeyPkg = await c.req.json(); // リクエストボディから公開鍵データ取得
  // 新しいKeyPackageオブジェクトを生成しデータベースに保存
  const keyId = await db.createKeyPackage(user, newKeyPkg);
  // ActorのkeyPackagesコレクションに追加 (ActivityPub Add活動を生成・連合配信)
  await federation.announceKeyAdd(user, keyId);
  return c.json({ result: "ok", keyId });
});

// 公開鍵削除
app.delete("/api/users/:user/keyPackages/:keyId", async (c) => {
  const user = c.req.param("user");
  const keyId = c.req.param("keyId");
  // KeyPackageをコレクションから削除しデータベース更新
  await db.removeKeyPackage(user, keyId);
  // ActivityPub Remove活動を生成・連合配信して周知
  await federation.announceKeyRemoval(user, keyId);
  return c.json({ result: "removed" });
});

// メッセージ送信
app.post("/api/users/:user/messages", async (c) => {
  const sender = c.req.param("user");
  const { to, content, mediaType, encoding } = await c.req.json();
  // Createアクティビティ作成（オブジェクトに暗号化メッセージを内包）
  const activity = buildCreateActivity(
    sender,
    to,
    content,
    mediaType,
    encoding,
  );
  // 送信者のアウトボックスに保存し、各受信者のサーバへ配送
  await db.saveOutbox(sender, activity);
  await federation.deliver(activity);
  return c.json({ result: "sent", id: activity.id });
});

// メッセージ受信取得
app.get("/api/users/:user/messages", async (c) => {
  const user = c.req.param("user");
  // ユーザーInboxから暗号化メッセージのみを抽出
  const messages = await db.getInboxEncryptedMessages(user);
  return c.json(messages);
});
```

上記の実装例では、`federation`というモジュールを仮定しており、そこでActivityPubサーバ間通信（連合）の処理を行っています。例えば`announceKeyAdd`では、新しい鍵を他サーバにも通知するために`Create`+`Add`アクティビティを生成して配信したり、`deliver`ではメッセージ配送のHTTP署名付きPOSTを行っています。また、`db`モジュールはサーバ内のデータストレージを抽象化したものです。Honoでは`c.req.json()`でリクエストボディのJSONを取得し、`c.json()`でJSONレスポンスを送るなど、シンプルなハンドラ記述が可能です。

### Denoプラットフォーム固有の注意点 (Deno-Specific Considerations)

Denoでサーバを実装・運用する際に留意すべき点を以下にまとめます。

- **セキュリティと実行許可:**
  Denoはデフォルトでファイルやネットワークへのアクセスが禁止されています。本システムを運用するには、サーバ間通信のためのネットワークアクセス権（`--allow-net`）や、データ永続化のためのファイルシステム権限（`--allow-read`および`--allow-write`、ファイル使用の場合）を付与して実行する必要があります。環境変数に秘密情報（例えばJWT署名鍵など）を入れる場合は`--allow-env`も指定します。**最小権限の原則**に従い、必要な権限のみに絞ってDenoプロセスを起動してください。

- **データストレージ:**
  Denoアプリでは、永続データの保存にいくつか選択肢があります。本仕様ではユーザーの鍵やメッセージメタデータを保存する必要があります。シンプルな実装にはDenoが提供する組み込みのキー値ストア「Deno
  KV」を利用できます。Deno KVは分散対応のKVストアで、Deno
  Deploy上でも利用可能です。これにより、キーコレクションやメッセージInbox/Outboxを永続化できます。他にもSQLiteやPostgreSQL等のデータベースを利用する場合、Deno用のドライバをインポートして使用可能ですが、`--allow-net`等でDB接続を許可する必要があります。

- **暗号ライブラリ:** Denoには標準で`crypto.subtle`（Web Crypto
  API）が組み込まれており、必要な暗号化・復号、署名検証などを行うことができます。たとえば、連合先サーバから受信したリクエストのHTTP署名検証や、クライアントからアップロードされた公開鍵の署名チェックなどは、Web
  Crypto
  APIで実装可能です。サーバ自体がメッセージ内容の暗号化/復号を行うことはありませんが、将来的にMLSプロトコルの一部をサーバで処理する場合（例えば、グループ管理の一環でサーバが特定の暗号計算を補助するケース）は、Deno上でRustで書かれた暗号ライブラリを動的ライブラリとしてロードすることも可能です（`--allow-ffi`が必要）。しかし基本方針として、サーバは暗号処理に関与しないため、Crypto
  APIの用途は限定的です。

- **Honoフレームワーク:** HonoはDeno DeployやCloudflare
  Workersなどでも動作するよう設計されています。Deno
  Deployに本システムをデプロイする場合、Honoアプリをそのままエッジ上で走らせることができます。Deno
  Deploy環境ではファイル書き込みができないため、Deno
  KVや外部データベース（外部への接続が必要）を使用してください。また、Honoはミドルウェアも充実しているため、認証用にJWTミドルウェアを利用したり、CORS設定を入れることも可能です。APIは主にクライアントアプリ（ネイティブアプリやWebフロントエンド）から利用されることを想定しており、必要に応じて`Access-Control-Allow-Origin`等のヘッダ設定もHonoのミドルウェアで行ってください。

- **パフォーマンスと同時接続:**
  DenoのHTTPサーバはシングルスレッドでイベント駆動ですが、高速なV8エンジン上で動作します。E2EE機能によりメッセージ数が増加した場合でも、暗号処理の大半はクライアント側で行われるためサーバ負荷は主にI/O（ネットワーク配送とデータ保存）になります。Honoは非同期I/Oを活かして高いパフォーマンスを発揮できますが、大規模トラフィックの場合はクラスタリング（複数Denoインスタンスを動かす）やCDNキャッシュ（公開鍵取得など静的に近いAPIへのキャッシュ適用）も検討してください。

## ActivityPubアクター及びメッセージ配信との統合 (Integration with ActivityPub Actors & Delivery)

E2EEメッセージング機能は、ActivityPubプロトコルの基盤の上に拡張として実装されます。その統合ポイントと動作について説明します。

- **アクターへのキー情報統合:**
  各ユーザーアカウントはActivityPubの「アクター」として表現されます。本仕様では、アクターオブジェクト（例:
  Personオブジェクト）のJSON表現に\*\*`keyPackages`プロパティ\*\*を追加します。これにより、そのユーザーの公開鍵パッケージ一覧をアクター情報の一部として公開することが可能です。`keyPackages`プロパティの値はActivityPubのCollectionであり、KeyPackageオブジェクトの集合を表します。連合先の他サーバは、あるユーザーにDM等を送る際、そのユーザーのアクターJSONを取得することで暗号化に必要な公開鍵（KeyPackage）一覧にアクセスできます。例えばWebFingerで`alice@example.com`を他サーバから発見した場合、その応答として得られるプロフィールURL（例:
  `https://example.com/users/alice`）にアクセスすれば、上記のように`keyPackages`フィールドを含むアクターJSONが取得できます。この仕組みにより、**鍵の配布はActivityPubレイヤーでシームレスに行われます**。なお、`keyPackages`プロパティを利用するために、アクターJSON内の`@context`にはMLS拡張のコンテキストURI
  (`https://purl.archive.org/socialweb/mls`)
  を追加しています。これにより、`keyPackages`や`PrivateMessage`といった拡張プロパティ・タイプをJSON-LDで解釈できるようにしています。非対応のクライアント・サーバであっても、この未知のプロパティを無視することで通常通りアクター情報を扱えるよう互換性に配慮しています。

- **メッセージ配送 (サーバ間):**
  暗号化メッセージ自体の配送はActivityPubのサーバ間連合プロトコルに完全に乗っかる形で行われます。送信者サーバでは、クライアントから受け取った暗号化メッセージ入りの`Create`アクティビティを送信者ユーザーのOutboxに格納すると同時に、各受信者のInbox（URL）に対してHTTPで送信します。配送時、HTTPリクエストは送信者アクターになりすまして署名されます（HTTP
  Signatureヘッダや、必要に応じてActivityPubのLD-Signatureを使用）。受信側サーバは署名を検証し、正当な送信元か確認した上で、自サーバ内の対象ユーザーのInboxコレクションにそのアクティビティを追加します。暗号化メッセージの場合、サーバはコンテンツの中身を理解しないため、フィルタリングや内容検査は行いません。ただし通常のActivityPubメッセージと同様に、受信サーバでスパム等のポリシーチェック（例:
  未知の拡張を拒否するかどうか）は適用される可能性があります。現状、Mastodon等多くの実装は未知のActivityStreams拡張要素に寛容であるため、`PrivateMessage`型やMLS拡張コンテキストが含まれていてもメッセージは配送・保存されると考えられます。

- **メッセージ配送 (クライアント取得):**
  受信者のクライアントは、自身のサーバのInboxから暗号化メッセージを取得します。上述の`GET /api/users/{user}/messages`エンドポイントは内部的にInboxコレクションを参照しています。ActivityPub仕様ではInboxはCollectionページをページングしつつGET取得する設計であり、クライアントがそれを直接扱うことも可能です。本APIでは利便性のため、新着かつ暗号化されたDMのみを返す絞り込みを提供しています。クライアントはInboxから取得した`Create`アクティビティを解析し、`object`内に`PrivateMessage`があれば、その`content`を取り出して復号処理を行います。受信ごとに必要ならクライアントは送信者のアクター情報を再度取得し、最新の公開鍵で暗号化されたメッセージか確認します。もっとも、メッセージ自体には暗号プロトコルのヘッダ情報が含まれており、どのセッション（どの鍵）で暗号化されたかを識別できます。クライアントは自分が保持するセッション状態（MLSのKeyStoreやラチェット状態）と突き合わせ、対応する秘密鍵で復号します。

- **フォロー関係と公開範囲:**
  E2EEメッセージは一種のダイレクトメッセージ（DM）ですが、通常のActivityPub
  DM（フォロワーにしか見えないTo/CC指定投稿）とは異なり**サーバ管理者でも内容を読めない**点が特徴です。そのため、メッセージの`to`には**特定のアクターのみ**を列挙する必要があります。`to`:
  `as:Public`（公開範囲: 全体）や、`to`にフォロワーコレクション（例:
  `alice@example.com`のFollowersコレクション）を指定することは**禁止**されます。これらを指定すると、不特定多数に暗号化メッセージをばら撒く形となり、鍵のないユーザーには無意味であるだけでなく、サーバ側でも処理や表示に困るためです。クライアントアプリはUI上で送信相手を明示的に選ばせることで、`to`を個別ユーザーに限定します。なお、`cc`プロパティも同様に使用しません（利用するとトゥート等の公開範囲と混同されるため）。E2EEメッセージは**明示的な対象者にのみ配信される**私信として位置づけられます。

- **他のActivityPubオブジェクトとの関係:**
  E2EEメッセージングは基本的に新設のオブジェクト種別（PrivateMessage等）として実装されるため、既存の公開投稿(
  Note
  等)とは独立しています。ただし、将来的には既存オブジェクトを暗号化してやり取りする「プライベート投稿」機能も考えられます。その場合、本仕様の枠組みを応用し、たとえば`Note`オブジェクトをそのままシリアライズして暗号化ペイロードに含めることも技術的には可能です。実際、SocialCGの提案では「暗号化されたNoteの作成・更新は、平文なら2つのCreate（作成と更新）のActivityPubイベントとなるものを、暗号化メッセージの中で表現する」といったモデルが示唆されています。本仕様では当面はテキスト中心のDMを対象としますが、将来的な拡張により画像やその他のActivityStreamsオブジェクトも暗号化コンテンツとして運べる設計になっています。

- **モデレーションとプライバシー:**
  エンドツーエンド暗号化により、サーバ管理者や連合の中間者はメッセージ内容を閲覧できなくなります。これはユーザーのプライバシー保護の面で利点ですが、同時に**悪用時のモデレーション（違反コンテンツへの対処）が難しくなる**という課題もあります。本仕様では、サーバは暗号化されたDM内容を検閲・分析しない前提ですので、仮に違法コンテンツや嫌がらせがE2EEメッセージ上で行われてもサーバ側では検知できません。対策としては、ユーザーからの通報機能を設け、**クライアントに平文を復号させた上で**その問題メッセージを運営に送信させる方法があります（例:
  WhatsAppが実装している「ユーザーが通報時に直近数件のメッセージを提供する」仕組み）。しかしこれはユーザーの任意協力に依存します。また鍵がきちんと検証されていない場合、中間サーバが偽鍵で盗聴する可能性もあります（前述のキー置換攻撃）。これらの課題はE2EE実装に付随するものですので、ソフトウェア提供者は利用規約等でE2EEメッセージの扱いと限界（「サーバでは内容を確認できない」等）を明示する必要があります。

以上のように、本仕様で追加するE2EEメッセージング機能は、ActivityPubのアクター・活動モデルに沿った形で統合されています。クライアント開発者は、このAPI仕様に従って鍵を配布・取得し、メッセージを暗号化して送受信することで、安全なダイレクトメッセージをユーザーに提供できます。サーバ開発者は、Honoフレームワークを用いた上記のような実装を参照しつつ、既存のActivityPub機能（フォロー・公開投稿等）と矛盾なくE2EE機能を組み込むことが可能です。将来的な標準化動向（例えばW3C
SocialCGでの議論やMLS/MIMI仕様策定）も踏まえ、拡張性を持たせた構成としています。

**引用情報 (References):**

- ActivityPub E2EE統合モデル – Social Web Incubator CG (SWICG) 提案資料
- Messaging Layer Security (MLS) over ActivityPub –
  キー管理とデータ形式に関するSWICGドラフト
- W3C Social Web Community Group 電子会議メモ (2024/09/25) –
  ActivityPubのE2EE拡張に関する議論
- SocialHub フォーラム – FediverseにおけるE2EEメッセージングの課題と提案
